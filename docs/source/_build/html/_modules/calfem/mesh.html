

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>calfem.mesh &mdash; CALFEM for Python 3.5.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> CALFEM for Python
          

          
          </a>

          
            
            
              <div class="version">
                3.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation instructions</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../calfem_examples.html">Using CALFEM for Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../calfem_mesh_guide.html">Mesh generation with CALFEM</a></li>
</ul>
<p class="caption"><span class="caption-text">Function Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../calfem_reference.html">Function reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">CALFEM for Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>calfem.mesh</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for calfem.mesh</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">calfem.core</span> <span class="kn">import</span> <span class="n">createdofs</span>
<span class="kn">from</span> <span class="nn">calfem.utils</span> <span class="kn">import</span> <span class="n">which</span>
<span class="kn">import</span> <span class="nn">calfem.core</span> <span class="k">as</span> <span class="nn">cfc</span>

<span class="kn">import</span> <span class="nn">logging</span> <span class="k">as</span> <span class="nn">cflog</span>

<span class="kn">import</span> <span class="nn">gmsh</span>

<div class="viewcode-block" id="error"><a class="viewcode-back" href="../../calfem_reference.html#calfem.mesh.error">[docs]</a><span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Log error message&quot;&quot;&quot;</span>
    <span class="n">cflog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


<div class="viewcode-block" id="info"><a class="viewcode-back" href="../../calfem_reference.html#calfem.mesh.info">[docs]</a><span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Log information message&quot;&quot;&quot;</span>
    <span class="n">cflog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span>

<span class="c1"># def dofsFromNodes(listOfNodes, dofs):</span>
<span class="c1">#        D = []</span>
<span class="c1">#        for node in listOfNodes:</span>
<span class="c1">#            D.extend(dofs[node])</span>
<span class="c1">#        return D</span>


<span class="k">def</span> <span class="nf">_offsetIndices</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Shifts the indices by offset. </span>
<span class="sd">    Positive offsets move the indices away from 0.</span>
<span class="sd">    Negative offsets move the indices towards 0.</span>
<span class="sd">    If an index is 0 the offset is added to it.&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">offset</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_formatList</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turns a list of numbers into a corresponding string of comma-separated numbers.</span>
<span class="sd">    The parameter offset is a number that is added to the numbers.</span>
<span class="sd">    Can be used for turning a list of 0-based indices into a corresponding string</span>
<span class="sd">    of comma-separated offset indices. Offsets depend on the sign, i.e. negative</span>
<span class="sd">    numbers get the offset subtracted.</span>
<span class="sd">    Do not use offsets on lists with negative float values. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Increment the indices by 1. Join list-elements as strings separated by &#39;, &#39;.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">_offsetIndices</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">offset</span><span class="p">)))</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="c1"># If lst is not iterable (causes TypeError), then it is probably an integer.</span>
        <span class="k">return</span> <span class="n">lst</span><span class="o">+</span><span class="n">offset</span>


<span class="k">def</span> <span class="nf">_insertInSetDict</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;inserts values at key in dictionary containing sets. Values may be</span>
<span class="sd">    a single value or iterable, in which case each value is inserted&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>
        <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="c1"># Exception if values is not an iterable - insert values itself instead.</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_insertBoundaryElement</span><span class="p">(</span><span class="n">boundaryElements</span><span class="p">,</span> <span class="n">elementType</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insert an element to the boundaryElements dict.</span>

<span class="sd">    Parameters:</span>

<span class="sd">        boundaryElements  Dictionary of boundary elements</span>

<span class="sd">        elementType       &#39;elm-type&#39; according to GMSH</span>

<span class="sd">        marker            Boundary marker</span>

<span class="sd">        nodes             List of element nodes, order according to GMSH</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">marker</span> <span class="ow">in</span> <span class="n">boundaryElements</span><span class="p">:</span>
        <span class="n">boundaryElements</span><span class="p">[</span><span class="n">marker</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">boundaryElements</span><span class="p">[</span><span class="n">marker</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">{</span><span class="s1">&#39;elm-type&#39;</span><span class="p">:</span> <span class="n">elementType</span><span class="p">,</span> <span class="s1">&#39;node-number-list&#39;</span><span class="p">:</span> <span class="n">nodes</span><span class="p">})</span>


<span class="k">def</span> <span class="nf">createGmshMesh</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">el_type</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">el_size_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dofs_per_node</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                   <span class="n">gmsh_exec_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clcurv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">min_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">meshing_algorithm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">additional_options</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>

    <span class="n">meshGen</span> <span class="o">=</span> <span class="n">GmshMeshGenerator</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">el_type</span><span class="p">,</span> <span class="n">el_size_factor</span><span class="p">,</span> <span class="n">dofs_per_node</span><span class="p">,</span>
                                <span class="n">gmsh_exec_path</span><span class="p">,</span> <span class="n">clcurv</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span> <span class="n">meshing_algorithm</span><span class="p">,</span>
                                <span class="n">additional_options</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">meshGen</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>


<span class="n">createMesh</span> <span class="o">=</span> <span class="n">createGmshMesh</span>
<span class="n">create_mesh</span> <span class="o">=</span> <span class="n">createGmshMesh</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">createGmshMesh</span>


<div class="viewcode-block" id="GmshMeshGenerator"><a class="viewcode-back" href="../../calfem_reference.html#calfem.mesh.GmshMeshGenerator">[docs]</a><span class="k">class</span> <span class="nc">GmshMeshGenerator</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Meshes geometry in GeoData objects or geo-files by calling the Gmsh executable.</span>
<span class="sd">    This is done when the function create() is called.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">el_type</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">el_size_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dofs_per_node</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">gmsh_exec_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clcurv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">min_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">meshing_algorithm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">additional_options</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mesh_dir</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">return_boundary_elements</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;        </span>
<span class="sd">        Parameters:</span>

<span class="sd">            geometry        GeoData instance or string containing path to .geo-file</span>

<span class="sd">            el_type        Integer. Element type and order. </span>
<span class="sd">                           See gmsh manual for details.</span>

<span class="sd">            el_size_factor  Float. Factor by which the element sizes are multiplied.</span>

<span class="sd">            dofs_per_node    Number of degrees of freedom per node.</span>

<span class="sd">            gmsh_exec_path   File path to where the gmsh executable is located.</span>

<span class="sd">            clcurv         Set to true to make elements smaller at high curvatures. </span>
<span class="sd">                           (Experimental option according to the gmsh manual)</span>

<span class="sd">            min_size        Minimum element size</span>

<span class="sd">            max_size        Maximum element size</span>

<span class="sd">            meshing_algorithm  String. Select mesh algorithm (&#39;meshadapt&#39;, &#39;del2d&#39;,</span>
<span class="sd">                              &#39;front2d&#39;,  &#39;del3d&#39;, &#39;front3d&#39;, ...). </span>
<span class="sd">                              See the gmsh manual for more info.</span>

<span class="sd">            return_boundary_elements  Flag for returning dictionary with boundary element</span>
<span class="sd">                                    information. Useful for applying loads on boundary.</span>

<span class="sd">            additional_options  String containing additional command line args for gmsh.</span>
<span class="sd">                               Use this if a gmsh option is not covered by the above </span>
<span class="sd">                               parameters (See section 3.3 in the gmsh manual for a </span>
<span class="sd">                               list of options)):</span>
<span class="sd">           &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">el_type</span> <span class="o">=</span> <span class="n">el_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">el_size_factor</span> <span class="o">=</span> <span class="n">el_size_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dofs_per_node</span> <span class="o">=</span> <span class="n">dofs_per_node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gmsh_exec_path</span> <span class="o">=</span> <span class="n">gmsh_exec_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clcurv</span> <span class="o">=</span> <span class="n">clcurv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_size</span> <span class="o">=</span> <span class="n">min_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="o">=</span> <span class="n">max_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshing_algorithm</span> <span class="o">=</span> <span class="n">meshing_algorithm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">additional_options</span> <span class="o">=</span> <span class="n">additional_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dir</span> <span class="o">=</span> <span class="n">mesh_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_boundary_elements</span> <span class="o">=</span> <span class="n">return_boundary_elements</span>

        <span class="c1"># gmsh elements that have rectangle faces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ElementsWithQuadFaces</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">92</span><span class="p">,</span> <span class="mi">93</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_2ndOrderElms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span>
                              <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span>
                              <span class="mi">19</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_2dOrderIncompleteElms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>
                                       <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">]</span>
        <span class="c1"># Apart from 16 the 2nd orders are totally untested. Only 16 (8-node quad)</span>
        <span class="c1"># is implemented in pycalfem though, so it does not matter.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_gmsh_module</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_gmsh_signal_handler</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_gmsh</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="GmshMeshGenerator.create"><a class="viewcode-back" href="../../calfem_reference.html#calfem.mesh.GmshMeshGenerator.create">[docs]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is3D</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Meshes a surface or volume defined by the geometry in geoData.</span>
<span class="sd">        Parameters:</span>
<span class="sd">        is3D - Optional parameter that only needs to be set if geometry</span>
<span class="sd">               is loaded from a geo-file, i.e. if geoData is a path string.</span>
<span class="sd">               Default False.</span>

<span class="sd">        Returns:</span>

<span class="sd">            coords          Node coordinates</span>

<span class="sd">                            [[n0_x, n0_y, n0_z],</span>
<span class="sd">                            [   ...           ],</span>
<span class="sd">                            [nn_x, nn_y, nn_z]]</span>

<span class="sd">            edof            Element topology</span>

<span class="sd">                            [[el0_dof1, ..., el0_dofn],</span>
<span class="sd">                            [          ...          ],</span>
<span class="sd">                            [eln_dof1, ..., eln_dofn]]</span>

<span class="sd">            dofs            Node dofs</span>

<span class="sd">                            [[n0_dof1, ..., n0_dofn],</span>
<span class="sd">                            [         ...         ],</span>
<span class="sd">                            [nn_dof1, ..., nn_dofn]]</span>

<span class="sd">            bdofs           Boundary dofs. Dictionary containing lists of dofs for</span>
<span class="sd">                            each boundary marker. Dictionary key = marker id.</span>

<span class="sd">            elementmarkers  List of integer markers. Row i contains the marker of</span>
<span class="sd">                            element i. Markers are similar to boundary markers and</span>
<span class="sd">                            can be used to identify in which region an element lies.</span>

<span class="sd">            boundaryElements  (optional) returned if self.return_boundary_elements is true.</span>
<span class="sd">                              Contains dictionary with boundary elements. The keys are markers</span>
<span class="sd">                              and the values are lists of elements for that marker.</span>

<span class="sd">        Running this function also creates object variables:</span>

<span class="sd">            nodesOnCurve    Dictionary containing lists of node-indices. Key is a </span>
<span class="sd">                            curve-ID and the value is a list of indices of all nodes</span>
<span class="sd">                            on that curve, including its end points.</span>

<span class="sd">            nodesOnSurface  Dictionary containing lists of node-indices. Key is a</span>
<span class="sd">                            surface-ID and the value is a list of indices of the nodes</span>
<span class="sd">                            on that surface, including its boundary.</span>

<span class="sd">            nodesOnVolume   Dictionary containing lists of node-indices. Key is a</span>
<span class="sd">                            volume-ID and the value is a list of indices of the nodes</span>
<span class="sd">                            in that volume, including its surface. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Nodes per element for different element types:</span>
        <span class="c1"># (taken from Chapter 9, page 89 of the gmsh manual)</span>
        <span class="n">nodesPerElmDict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>   <span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>   <span class="mi">3</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>   <span class="mi">4</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>   <span class="mi">5</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                           <span class="mi">6</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>   <span class="mi">7</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>   <span class="mi">8</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>   <span class="mi">9</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">10</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
                           <span class="mi">11</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">14</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                           <span class="mi">16</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>  <span class="mi">17</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">18</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">19</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">20</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
                           <span class="mi">21</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">22</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">23</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">24</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">25</span><span class="p">:</span> <span class="mi">21</span><span class="p">,</span>
                           <span class="mi">26</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">27</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>  <span class="mi">28</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">29</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">:</span> <span class="mi">35</span><span class="p">,</span>
                           <span class="mi">31</span><span class="p">:</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">92</span><span class="p">:</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">93</span><span class="p">:</span> <span class="mi">125</span><span class="p">}</span>
        <span class="n">nodesPerElement</span> <span class="o">=</span> <span class="n">nodesPerElmDict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">el_type</span><span class="p">]</span>

        <span class="c1"># Check for GMSH executable </span>
        <span class="c1"># </span>
        <span class="c1"># Consider using the gmsh_extension module</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_gmsh_module</span><span class="p">:</span>
            <span class="n">gmshExe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmsh_exec_path</span>
            <span class="k">if</span> <span class="n">gmshExe</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gmshExe</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
                    <span class="n">gmshExe</span> <span class="o">=</span> <span class="n">which</span><span class="p">(</span><span class="s2">&quot;gmsh.bat&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">gmshExe</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">gmshExe</span> <span class="o">=</span> <span class="n">which</span><span class="p">(</span><span class="s2">&quot;gmsh.exe&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gmshExe</span> <span class="o">=</span> <span class="n">which</span><span class="p">(</span><span class="s2">&quot;gmsh&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gmshExe</span><span class="p">):</span>
                    <span class="n">gmshExe</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmsh_exec_path</span><span class="p">)</span>  <span class="c1"># Try relative path</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gmshExe</span><span class="p">):</span>
                        <span class="n">gmshExe</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Relative path didnt work either</span>

            <span class="k">if</span> <span class="n">gmshExe</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                    <span class="s2">&quot;Error: Could not find GMSH. Please make sure that the \GMSH executable is available on the search path (PATH).&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Info    : GMSH -&gt; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">gmshExe</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Info    : GMSH -&gt; Python-module&quot;</span><span class="p">)</span>

        <span class="c1"># Create a temporary directory for GMSH</span>

        <span class="n">oldStyleTempDir</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dir</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">tempMeshDir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dir</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">tempMeshDir</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tempMeshDir</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tempMeshDir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>

        <span class="c1"># If geometry data is given as a .geo file we will just pass it on to gmsh later.</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">geoFilePath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>

            <span class="c1"># In this case geoData is a path string, so the dimension must be supplied by the user.</span>

            <span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">is3D</span> <span class="k">else</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">geoFilePath</span><span class="p">):</span>
                <span class="n">geoFilePath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">geoFilePath</span><span class="p">)</span>  <span class="c1"># Try relative path</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">geoFilePath</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                        <span class="s2">&quot;Error: Could not find geo-file &quot;</span> <span class="o">+</span> <span class="n">geoFilePath</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Get the dimension of the model from geoData.</span>

            <span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">is3D</span> <span class="k">else</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">oldStyleTempDir</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s2">&quot;./gmshMeshTemp&quot;</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s2">&quot;./gmshMeshTemp&quot;</span><span class="p">)</span>
                <span class="n">geoFilePath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="s2">&quot;gmshMeshTemp/tempGeometry.geo&quot;</span><span class="p">))</span>  <span class="c1"># &quot;gmshMeshTemp/tempGeometry.geo&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">geoFilePath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tempMeshDir</span><span class="p">,</span> <span class="s1">&#39;tempGeometry.geo&#39;</span><span class="p">))</span>

            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">geoFilePath</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_writeGeoFile</span><span class="p">()</span>  <span class="c1"># Write geoData to file</span>

        <span class="k">if</span> <span class="n">oldStyleTempDir</span><span class="p">:</span>

            <span class="c1"># Filepath to the msh-file that will be generated.</span>

            <span class="n">mshFileName</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="s1">&#39;gmshMeshTemp/meshFile.msh&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mshFileName</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tempMeshDir</span><span class="p">,</span> <span class="s1">&#39;meshFile.msh&#39;</span><span class="p">))</span>

        <span class="c1"># construct options string:</span>

        <span class="n">options</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="s1">&#39; -&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="s1">&#39; -clscale &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">el_size_factor</span><span class="p">)</span>  <span class="c1"># scale factor</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="s1">&#39; -o </span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mshFileName</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="s1">&#39; -clcurv&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clcurv</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="s1">&#39; -clmin &#39;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_size</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="s1">&#39; -clmax &#39;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_size</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="s1">&#39; -algo &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshing_algorithm</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshing_algorithm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="s1">&#39; -order 2&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_2ndOrderElms</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="s1">&#39; -format msh22&#39;</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="s1">&#39; -v 5&#39;</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_options</span>

        <span class="c1"># Execute gmsh</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_gmsh_module</span><span class="p">:</span>

            <span class="c1"># Meshing using gmsh extension module</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_gmsh</span><span class="p">:</span>
                <span class="n">gmsh</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>

            <span class="c1"># This is a hack to enable the use of gmsh in </span>
            <span class="c1"># a separate thread.</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_gmsh_signal_handler</span><span class="p">:</span>
                <span class="n">gmsh</span><span class="o">.</span><span class="n">oldsig</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Load .geo file</span>

            <span class="n">gmsh</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">geoFilePath</span><span class="p">)</span>
            <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">geo</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

            <span class="c1"># Set meshing options</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_2ndOrderElms</span><span class="p">:</span>
                <span class="n">gmsh</span><span class="o">.</span><span class="n">option</span><span class="o">.</span><span class="n">setNumber</span><span class="p">(</span><span class="s2">&quot;Mesh.ElementOrder&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshing_algorithm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gmsh</span><span class="o">.</span><span class="n">option</span><span class="o">.</span><span class="n">setString</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshing_algorithm</span><span class="p">)</span>
            
            <span class="n">gmsh</span><span class="o">.</span><span class="n">option</span><span class="o">.</span><span class="n">setNumber</span><span class="p">(</span><span class="s2">&quot;Mesh.MshFileVersion&quot;</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">)</span>
            <span class="n">gmsh</span><span class="o">.</span><span class="n">option</span><span class="o">.</span><span class="n">setNumber</span><span class="p">(</span><span class="s2">&quot;Mesh.MeshSizeFactor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_size_factor</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clcurv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gmsh</span><span class="o">.</span><span class="n">option</span><span class="o">.</span><span class="n">setNumber</span><span class="p">(</span><span class="s2">&quot;Mesh.MeshSizeFromCurvature&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">clcurv</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gmsh</span><span class="o">.</span><span class="n">option</span><span class="o">.</span><span class="n">setNumber</span><span class="p">(</span><span class="s1">&#39;Mesh.MeshSizeMin&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_size</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gmsh</span><span class="o">.</span><span class="n">option</span><span class="o">.</span><span class="n">setNumber</span><span class="p">(</span><span class="s1">&#39;Mesh.MeshSizeMax&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span><span class="p">)</span>

            <span class="c1"># Generate mesh</span>

            <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Write .msh file</span>

            <span class="n">gmsh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mshFileName</span><span class="p">)</span>

            <span class="c1"># Close extension module</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_gmsh</span><span class="p">:</span>
                <span class="n">gmsh</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gmshExe</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">gmshExe</span><span class="p">)</span>
            <span class="n">info</span><span class="p">(</span><span class="s2">&quot;GMSH binary: &quot;</span><span class="o">+</span><span class="n">gmshExe</span><span class="p">)</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot; &quot;</span><span class="si">%s</span><span class="s1">&quot; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">gmshExe</span><span class="p">,</span> <span class="n">geoFilePath</span><span class="p">,</span> <span class="n">options</span><span class="p">),</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        
        <span class="c1"># Read generated msh file:</span>
        <span class="c1"># print(&quot;Opening msh file &quot; + mshFileName)#TEMP</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">mshFileName</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mshFile</span><span class="p">:</span>

            <span class="n">info</span><span class="p">(</span><span class="s2">&quot;Mesh file  : &quot;</span><span class="o">+</span><span class="n">mshFileName</span><span class="p">)</span>

            <span class="c1"># print(&quot;Reading msh file...&quot;)</span>

            <span class="n">ln</span> <span class="o">=</span> <span class="n">mshFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="k">while</span><span class="p">(</span><span class="n">ln</span> <span class="o">!=</span> <span class="s1">&#39;$Nodes</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>  <span class="c1"># Read until we find the nodes</span>
                <span class="n">ln</span> <span class="o">=</span> <span class="n">mshFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="n">nbrNodes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mshFile</span><span class="o">.</span><span class="n">readline</span><span class="p">())</span>
            <span class="n">allNodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbrNodes</span><span class="p">,</span> <span class="n">dim</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbrNodes</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">mshFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>

                <span class="c1"># Grab the coordinates (1:3 if 2D, 1:4 if 3D)</span>

                <span class="n">allNodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">while</span><span class="p">(</span><span class="n">mshFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;$Elements</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>  <span class="c1"># Read until we find the elements</span>
                <span class="k">pass</span>

            <span class="c1"># The nbr of elements (including marker elements).</span>

            <span class="n">nbrElements</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mshFile</span><span class="o">.</span><span class="n">readline</span><span class="p">())</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">elementmarkers</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># temp dictionary of sets. Key:MarkerID. Value:Set. The sets will be converted to lists.</span>

            <span class="n">bdofs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">boundaryElements</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># nodeOnPoint = {}  #dictionary pointID : nodeNumber</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">nodesOnCurve</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dictionary lineID  : set of [nodeNumber]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodesOnSurface</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dictionary surfID  : set of [nodeNumber]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodesOnVolume</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dictionary volID   : set of [nodeNumber]</span>

            <span class="c1"># Read all elements (points, surfaces, etc):</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbrElements</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">mshFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
                <span class="n">eType</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># second int is the element type.</span>
                <span class="n">nbrTags</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># Third int is the nbr of tags on this element.</span>
                <span class="n">marker</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># Fourth int (first tag) is the marker.</span>

                <span class="c1"># Fifth int  is the ID of the geometric entity (points, curves, etc) that the element belongs to</span>

                <span class="n">entityID</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

                <span class="c1"># The rest after tags are node indices.</span>

                <span class="n">nodes</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">3</span><span class="o">+</span><span class="n">nbrTags</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)]</span>

                <span class="c1"># If the element type is the kind of element we are looking for:</span>

                <span class="k">if</span><span class="p">(</span><span class="n">eType</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_type</span><span class="p">):</span>

                    <span class="c1"># Add the nodes of the elements to the list.</span>

                    <span class="n">elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

                    <span class="c1"># Add element marker. It is used for keeping track of elements (thickness, heat-production and such)</span>

                    <span class="n">elementmarkers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># If the element is not a &quot;real&quot; element we store its node at marker in bdof instead:</span>
                    <span class="n">_insertInSetDict</span><span class="p">(</span><span class="n">bdofs</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

                    <span class="c1"># We also store the full information as &#39;boundary elements&#39;</span>

                    <span class="n">_insertBoundaryElement</span><span class="p">(</span><span class="n">boundaryElements</span><span class="p">,</span> <span class="n">eType</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

                <span class="c1"># if eType == 15: #If point. Commmented away because points only make elements if they have non-zero markers, so nodeOnPoint is not very useful.</span>
                <span class="c1">#    nodeOnPoint[entityID-1] = nodes[0] #insert node into nodeOnPoint. (ID-1 because we want 0-based indices)</span>

                <span class="k">if</span> <span class="n">eType</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">28</span><span class="p">]:</span>  <span class="c1"># If line</span>

                    <span class="c1"># insert nodes into nodesOnCurve</span>

                    <span class="n">_insertInSetDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodesOnCurve</span><span class="p">,</span> <span class="n">entityID</span> <span class="o">-</span>
                                    <span class="mi">1</span><span class="p">,</span> <span class="n">_offsetIndices</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">eType</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">25</span><span class="p">]:</span>  <span class="c1"># If surfaceelement</span>

                    <span class="c1"># insert nodes into nodesOnSurface</span>

                    <span class="n">_insertInSetDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodesOnSurface</span><span class="p">,</span> <span class="n">entityID</span> <span class="o">-</span>
                                    <span class="mi">1</span><span class="p">,</span> <span class="n">_offsetIndices</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>  
                    
                    <span class="c1"># if volume element.</span>

                    <span class="n">_insertInSetDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodesOnVolume</span><span class="p">,</span> <span class="n">entityID</span> <span class="o">-</span>
                                    <span class="mi">1</span><span class="p">,</span> <span class="n">_offsetIndices</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">bdofs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>  <span class="c1"># Convert the sets of boundary nodes to lists.</span>
                <span class="n">bdofs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bdofs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodesOnCurve</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>  <span class="c1"># Convert set to list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodesOnCurve</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodesOnCurve</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodesOnSurface</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>  <span class="c1"># Convert set to list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodesOnSurface</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodesOnSurface</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodesOnVolume</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>  <span class="c1"># Convert set to list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodesOnVolume</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodesOnVolume</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="c1"># Remove temporary mesh directory if not explicetly specified.</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dir</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">tempMeshDir</span><span class="p">)</span>

        <span class="n">dofs</span> <span class="o">=</span> <span class="n">createdofs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">allNodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dofs_per_node</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dofs_per_node</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># This if-chunk copied from pycalfem_utils.py</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">topo</span> <span class="o">=</span> <span class="n">elements</span>
            <span class="n">expandedElements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">nodesPerElement</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dofs_per_node</span><span class="p">),</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span>
            <span class="n">elIdx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">elementTopo</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nodesPerElement</span><span class="p">):</span>
                    <span class="n">expandedElements</span><span class="p">[</span><span class="n">elIdx</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dofs_per_node</span><span class="p">:(</span>
                        <span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dofs_per_node</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">dofs_per_node</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dofs</span><span class="p">[</span><span class="n">elementTopo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">elIdx</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">keyID</span> <span class="ow">in</span> <span class="n">bdofs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">bVerts</span> <span class="o">=</span> <span class="n">bdofs</span><span class="p">[</span><span class="n">keyID</span><span class="p">]</span>
                <span class="n">bVertsNew</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bVerts</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dofs_per_node</span><span class="p">):</span>
                        <span class="n">bVertsNew</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dofs</span><span class="p">[</span><span class="n">bVerts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                <span class="n">bdofs</span><span class="p">[</span><span class="n">keyID</span><span class="p">]</span> <span class="o">=</span> <span class="n">bVertsNew</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_boundary_elements</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">allNodes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">expandedElements</span><span class="p">),</span> <span class="n">dofs</span><span class="p">,</span> <span class="n">bdofs</span><span class="p">,</span> <span class="n">elementmarkers</span><span class="p">,</span> <span class="n">boundaryElements</span>
            <span class="k">return</span> <span class="n">allNodes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">expandedElements</span><span class="p">),</span> <span class="n">dofs</span><span class="p">,</span> <span class="n">bdofs</span><span class="p">,</span> <span class="n">elementmarkers</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_boundary_elements</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">allNodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">dofs</span><span class="p">,</span> <span class="n">bdofs</span><span class="p">,</span> <span class="n">elementmarkers</span><span class="p">,</span> <span class="n">boundaryElements</span>
        <span class="k">return</span> <span class="n">allNodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">dofs</span><span class="p">,</span> <span class="n">bdofs</span><span class="p">,</span> <span class="n">elementmarkers</span></div>

    <span class="k">def</span> <span class="nf">_writeGeoFile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># key is marker, value is a list of point indices (0-based) with that marker</span>

        <span class="n">pointMarkers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">curveMarkers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">surfaceMarkers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">volumeMarkers</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># WRITE POINTS:</span>

        <span class="k">for</span> <span class="n">ID</span><span class="p">,</span> <span class="p">[</span><span class="n">coords</span><span class="p">,</span> <span class="n">elSize</span><span class="p">,</span> <span class="n">marker</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Point(</span><span class="si">%i</span><span class="s2">) = {</span><span class="si">%s</span><span class="s2">};</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">ID</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">_formatList</span><span class="p">(</span><span class="n">coords</span> <span class="o">+</span> <span class="p">[</span><span class="n">elSize</span><span class="p">])))</span>
            <span class="n">_insertInSetDict</span><span class="p">(</span><span class="n">pointMarkers</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">ID</span><span class="p">)</span>

        <span class="c1"># WRITE CURVES:</span>

        <span class="k">for</span> <span class="n">ID</span><span class="p">,</span> <span class="p">[</span><span class="n">curveName</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">elOnCurve</span><span class="p">,</span> <span class="n">distributionString</span><span class="p">,</span> <span class="n">distributionVal</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">curves</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%i</span><span class="s2">) = {</span><span class="si">%s</span><span class="s2">};</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">curveName</span><span class="p">,</span> <span class="n">ID</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">_formatList</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

            <span class="c1"># Transfinite Line{2} = 20 Using Bump 0.05;</span>

            <span class="k">if</span> <span class="n">elOnCurve</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">distribution</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">distributionString</span> <span class="o">==</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;Using </span><span class="si">%s</span><span class="s2"> </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">distributionString</span><span class="p">,</span> <span class="n">distributionVal</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Transfinite Line{</span><span class="si">%i</span><span class="s2">} = </span><span class="si">%i</span><span class="s2"> </span><span class="si">%s</span><span class="s2">;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">ID</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">elOnCurve</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">distribution</span><span class="p">))</span>

                <span class="c1"># +1 on elOnCurve because gmsh actually takes the number of nodes on the curve, not elements on the curve.</span>

            <span class="n">_insertInSetDict</span><span class="p">(</span><span class="n">curveMarkers</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">ID</span><span class="p">)</span>

        <span class="c1"># WRITE SURFACES:</span>

        <span class="k">for</span> <span class="n">ID</span><span class="p">,</span> <span class="p">[</span><span class="n">surfName</span><span class="p">,</span> <span class="n">outerLoop</span><span class="p">,</span> <span class="n">holes</span><span class="p">,</span> <span class="n">ID</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">isStructured</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">surfaces</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># First we write line loops for the surface edge and holes (if there are any holes):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_writeLineLoop</span><span class="p">(</span><span class="n">outerLoop</span><span class="p">,</span> <span class="n">ID</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">holeIDs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hole</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">holes</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">holes</span><span class="p">))):</span>

                <span class="c1"># Create a hopefully unique ID-number for the line loop: Like 10015 or 1540035</span>
                <span class="c1"># (If gmsh uses 32-bit integers for IDs then IDs over 214&#39;748 will break)</span>

                <span class="n">holeID</span> <span class="o">=</span> <span class="mi">10000</span> <span class="o">*</span> <span class="p">(</span><span class="n">ID</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">5</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_writeLineLoop</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="n">holeID</span><span class="p">)</span>
                <span class="n">holeIDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">holeID</span><span class="p">)</span>

            <span class="c1"># Second, we write the surface itself:</span>
            <span class="c1"># If we have hole we want to include them in the surface.</span>

            <span class="n">holeString</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">holeIDs</span> <span class="k">else</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="n">_formatList</span><span class="p">(</span><span class="n">holeIDs</span><span class="p">)</span>

            <span class="c1"># Like &quot;Plane Surface(2) = {4, 2, 6, 8}</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%i</span><span class="s2">) = {</span><span class="si">%s%s</span><span class="s2">};</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">surfName</span><span class="p">,</span> <span class="n">ID</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ID</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">holeString</span><span class="p">))</span>

            <span class="c1"># Lastly, we make the surface transfinite if it is a structured surface:</span>

            <span class="k">if</span> <span class="n">isStructured</span><span class="p">:</span>
                <span class="n">cornerPoints</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

                <span class="c1"># Find the corner points. This is possibly unnecessary since Gmsh can do this automatically.</span>

                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">outerLoop</span><span class="p">:</span>
                    <span class="n">curvePoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">curves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">cornerPoints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curvePoints</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">cornerPoints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curvePoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">cornerPoints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cornerPoints</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Transfinite Surface{</span><span class="si">%i</span><span class="s2">} = {</span><span class="si">%s</span><span class="s2">};</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">ID</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">_formatList</span><span class="p">(</span><span class="n">cornerPoints</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>  <span class="c1"># Like Transfinite Surface{1} = {1,2,3,4};</span>

                <span class="c1"># Transfinite Surface has an optional argument (about triangle orientation) that is not implemented here.</span>

            <span class="n">_insertInSetDict</span><span class="p">(</span><span class="n">surfaceMarkers</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">ID</span><span class="p">)</span>

        <span class="c1"># WRITE VOLUMES:</span>

        <span class="k">for</span> <span class="n">ID</span><span class="p">,</span> <span class="p">[</span><span class="n">outerLoop</span><span class="p">,</span> <span class="n">holes</span><span class="p">,</span> <span class="n">ID</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">isStructured</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">volumes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># Surface loops for the volume boundary and holes (if any):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_writeSurfaceLoop</span><span class="p">(</span><span class="n">outerLoop</span><span class="p">,</span> <span class="n">ID</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">holeIDs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hole</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">holes</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">holes</span><span class="p">))):</span>

                <span class="c1"># ID-number for the hole surface loop</span>

                <span class="n">holeID</span> <span class="o">=</span> <span class="mi">10000</span> <span class="o">*</span> <span class="p">(</span><span class="n">ID</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">7</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_writeSurfaceLoop</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="n">holeID</span><span class="p">)</span>
                <span class="n">holeIDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">holeID</span><span class="p">)</span>

            <span class="c1"># Write the volume itself:</span>
            <span class="c1"># If we have hole we want to include them in the surface.</span>

            <span class="n">holeString</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">holeIDs</span> <span class="k">else</span> <span class="s2">&quot; , &quot;</span> <span class="o">+</span> <span class="n">_formatList</span><span class="p">(</span><span class="n">holeIDs</span><span class="p">)</span>

            <span class="c1"># Like &quot;Plane Surface(2) = {4, 2, 6, 8}</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;Volume(</span><span class="si">%i</span><span class="s2">) = {</span><span class="si">%s%s</span><span class="s2">};</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ID</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ID</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">holeString</span><span class="p">))</span>

            <span class="c1"># Lastly, we make the volume transfinite if it is a structured volume:</span>

            <span class="k">if</span> <span class="n">isStructured</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Transfinite Volume{</span><span class="si">%i</span><span class="s2">} = </span><span class="si">{}</span><span class="s2">;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ID</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

                <span class="c1"># We don&#39;t find the corner points of the structured volume like we did with the surfaces. Gmsh can actually find the corners automatically.</span>

            <span class="n">_insertInSetDict</span><span class="p">(</span><span class="n">volumeMarkers</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">ID</span><span class="p">)</span>

        <span class="c1"># MAYBE MAKE QUADS:</span>

        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">el_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ElementsWithQuadFaces</span><span class="p">):</span>  <span class="c1"># If we have quads surfaces on the elements</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Mesh.RecombineAll = 1;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># WRITE POINT MARKERS:</span>

        <span class="k">for</span> <span class="n">marker</span><span class="p">,</span> <span class="n">IDlist</span> <span class="ow">in</span> <span class="n">pointMarkers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">marker</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Physical Point(</span><span class="si">%i</span><span class="s2">) = {</span><span class="si">%s</span><span class="s2">};</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">marker</span><span class="p">,</span> <span class="n">_formatList</span><span class="p">(</span><span class="n">IDlist</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># WRITE CURVE MARKERS:</span>

        <span class="k">for</span> <span class="n">marker</span><span class="p">,</span> <span class="n">IDlist</span> <span class="ow">in</span> <span class="n">curveMarkers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Physical Line(</span><span class="si">%i</span><span class="s2">) = {</span><span class="si">%s</span><span class="s2">};</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">marker</span><span class="p">,</span> <span class="n">_formatList</span><span class="p">(</span><span class="n">IDlist</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># WRITE SURFACE MARKERS:</span>

        <span class="k">for</span> <span class="n">marker</span><span class="p">,</span> <span class="n">IDlist</span> <span class="ow">in</span> <span class="n">surfaceMarkers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Physical Surface(</span><span class="si">%i</span><span class="s2">) = {</span><span class="si">%s</span><span class="s2">};</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">marker</span><span class="p">,</span> <span class="n">_formatList</span><span class="p">(</span><span class="n">IDlist</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># WRITE SURFACE MARKERS:</span>
        <span class="k">for</span> <span class="n">marker</span><span class="p">,</span> <span class="n">IDlist</span> <span class="ow">in</span> <span class="n">volumeMarkers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Physical Volume(</span><span class="si">%i</span><span class="s2">) = {</span><span class="si">%s</span><span class="s2">};</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">marker</span><span class="p">,</span> <span class="n">_formatList</span><span class="p">(</span><span class="n">IDlist</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># If the element type is of an incomplete second order type</span>
        <span class="c1"># (i.e it is an 2nd order element without nodes in the middle of the element face),</span>
        <span class="c1"># then we need to specify this in the geo-file:</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_2dOrderIncompleteElms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Mesh.SecondOrderIncomplete=1;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_writeLineLoop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lineIndices</span><span class="p">,</span> <span class="n">loopID</span><span class="p">):</span>

        <span class="c1"># endPoints is used to keep track of at which points the curves start and end (i.e the direction of the curves)</span>

        <span class="n">endPoints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># lineIndices is a list of curve indices (0-based here, but 1-based later in the method)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lineIndices</span><span class="p">:</span>
            <span class="n">curvePoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">curves</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">endPoints</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">curvePoints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">curvePoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># We need the indices to be 1-based rather than 0-based in the next loop. (Some indices will be preceded by a minus-sign)</span>

        <span class="n">lineIndices</span> <span class="o">=</span> <span class="n">_offsetIndices</span><span class="p">(</span><span class="n">lineIndices</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">isFirstLine</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">nbrLinesinLoop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineIndices</span><span class="p">)</span>

        <span class="c1"># In this loop we reverse the direction of some lines in the LineLoop to make them conform to the format that Gmsh expects.</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbrLinesinLoop</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">isFirstLine</span> <span class="ow">and</span> <span class="n">nbrLinesinLoop</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">isFirstLine</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># If last point of the first line exists in the endpoints of the second line... Do nothing</span>

                <span class="k">if</span> <span class="n">endPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">endPoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">pass</span>

                <span class="c1"># Else if the first point in the first line exists in the endpoints of the second line:</span>

                <span class="k">elif</span> <span class="n">endPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">endPoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">endPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                    <span class="n">lineIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Reverse the direction of the line</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s2">&quot;ERROR: The first curve of line-loop </span><span class="si">%i</span><span class="s2"> does not link up to the subsequent curve&quot;</span> <span class="o">%</span> <span class="n">loopID</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">endPoints</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">endPoints</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">endPoints</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">endPoints</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">endPoints</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">lineIndices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Reverse the direction of the line</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;ERROR: The </span><span class="si">%i</span><span class="s2"> th curve (starting from 0) of a line-loop </span><span class="si">%i</span><span class="s2"> does not link up with the preceding curve&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">loopID</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">nbrLinesinLoop</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">endPoints</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">endPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># If last line AND the last point of the last curve not equal the first point of the first curve:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;ERROR: The last curve of a line-loop </span><span class="si">%i</span><span class="s2"> does not join up with the first curve&quot;</span> <span class="o">%</span> <span class="n">loopID</span><span class="p">)</span>

        <span class="c1"># If the model is in 2D we need to make all line loops counter-clockwise so surface normals point in the positive z-direction.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">is3D</span><span class="p">:</span>
            <span class="n">lineIndices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_makeCounterClockwise</span><span class="p">(</span><span class="n">lineIndices</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Line Loop(</span><span class="si">%i</span><span class="s2">) = {</span><span class="si">%s</span><span class="s2">};</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">loopID</span><span class="p">,</span> <span class="n">_formatList</span><span class="p">(</span>
            <span class="n">lineIndices</span><span class="p">)))</span>  <span class="c1"># (lineIndices are alreay 1-based here)</span>

    <span class="k">def</span> <span class="nf">_makeCounterClockwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lineIndices</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;If the lineIndices describe a line loop that is not counterclockwise,</span>
<span class="sd">        this function will return a counterclockwise version of lineIndices</span>
<span class="sd">        (i.e. all indices multiplied by -1).</span>
<span class="sd">        lineIndices is a list of integers (1-based line indices) that may be negative, but not 0&#39;&#39;&#39;</span>

        <span class="c1"># Method described at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-points-are-in-clockwise-order</span>

        <span class="n">summa</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Counter-clockwise if the sum ends up negative.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">lineIndices</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="c1"># Make a copy of the line index that is positive and 0-based.</span>
            <span class="n">realIndex</span> <span class="o">=</span> <span class="n">sign</span><span class="o">*</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">curveType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">curves</span><span class="p">[</span><span class="n">realIndex</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pointIDs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">curves</span><span class="p">[</span><span class="n">realIndex</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">curveType</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Spline&#39;</span><span class="p">,</span> <span class="s1">&#39;BSpline&#39;</span><span class="p">]:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">ID</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">ID</span> <span class="ow">in</span> <span class="n">pointIDs</span><span class="p">]</span>  <span class="c1"># [[x,y,z], [x,y,z], ...]</span>
                <span class="c1"># Reverse the order of the points if the curve direction is reversed.</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">points</span> <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">points</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># For every point along the curve except the last:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pointIDs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># (x2-x1)(y2+y1).</span>
                    <span class="n">summa</span> <span class="o">+=</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> \
                        <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">curveType</span> <span class="o">==</span> <span class="s1">&#39;Circle&#39;</span><span class="p">:</span>
                <span class="c1"># We will find a point &#39;d&#39; on the middle of the circle arc, and use a-d-c as approximation of the arc.</span>
                <span class="c1"># 3-by-3 array. The rows are start-center-end points and columns are x,y,z.</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">ID</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                                   <span class="k">for</span> <span class="n">ID</span> <span class="ow">in</span> <span class="n">pointIDs</span><span class="p">])</span>
                <span class="c1"># Reverse the order of the points if the curve direction is reversed.</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">points</span> <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">points</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># start</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># center</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># end</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># radius</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">approxArc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">approxArc</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># (x2-x1)(y2+y1).</span>
                    <span class="n">summa</span> <span class="o">+=</span> <span class="p">(</span><span class="n">approxArc</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">approxArc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> \
                        <span class="p">(</span><span class="n">approxArc</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">approxArc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">curveType</span> <span class="o">==</span> <span class="s1">&#39;Ellipse&#39;</span><span class="p">:</span>
                <span class="c1"># We will find a point &#39;d&#39; near the middle of the circle arc, and use a-d-c as approximation of the arc.</span>
                <span class="c1"># The only difference from the circle above, is that the radius at d is approximated as the mean distance between</span>
                <span class="c1"># the center and the two other points.</span>
                <span class="c1"># 4-by-3 array. The rows are start-center-majAxis-end points and columns are x,y,z.</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">ID</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                                   <span class="k">for</span> <span class="n">ID</span> <span class="ow">in</span> <span class="n">pointIDs</span><span class="p">])</span>
                <span class="c1"># skip the major axis point (row 2)</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">:]</span>
                <span class="c1"># Reverse the order of the points if the curve direction is reversed.</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">points</span> <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">points</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># start</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># center</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># end</span>
                <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="n">b</span><span class="p">))</span> <span class="o">/</span> \
                    <span class="mi">2</span>  <span class="c1"># approximate radius</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">approxArc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">approxArc</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># (x2-x1)(y2+y1).</span>
                    <span class="n">summa</span> <span class="o">+=</span> <span class="p">(</span><span class="n">approxArc</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">approxArc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> \
                        <span class="p">(</span><span class="n">approxArc</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">approxArc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># If the sum is positive the loop (closed polygon) is clockwise, so reverse the direction of all curves:</span>
        <span class="k">if</span> <span class="n">summa</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lineIndices</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lineIndices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">lineIndices</span>

    <span class="k">def</span> <span class="nf">_writeSurfaceLoop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outerLoop</span><span class="p">,</span> <span class="n">ID</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Surface Loop(</span><span class="si">%i</span><span class="s2">) = {</span><span class="si">%s</span><span class="s2">};</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">ID</span><span class="p">,</span> <span class="n">_formatList</span><span class="p">(</span><span class="n">outerLoop</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="c1"># --- Compatibility properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elType</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_type</span>

    <span class="nd">@elType</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">elType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">el_type</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elSizeFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_size_factor</span>

    <span class="nd">@elSizeFactor</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">elSizeFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">el_size_factor</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dofsPerNode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dofs_per_node</span>

    <span class="nd">@dofsPerNode</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dofsPerNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dofs_per_node</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gmshExecPath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmsh_exec_path</span>

    <span class="nd">@gmshExecPath</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gmshExecPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gmsh_exec_path</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">minSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_size</span>

    <span class="nd">@minSize</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">minSize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_size</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">maxSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span>

    <span class="nd">@maxSize</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">maxSize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">meshingAlgorithm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshing_algorithm</span>

    <span class="nd">@meshingAlgorithm</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">meshingAlgorithm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshing_algorithm</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">additionalOptions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_options</span>

    <span class="nd">@additionalOptions</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">additionalOptions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">additional_options</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">meshDir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dir</span>

    <span class="nd">@meshDir</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">meshDir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dir</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">returnBoundaryElements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_boundary_elements</span>

    <span class="nd">@returnBoundaryElements</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">returnBoundaryElements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_boundary_elements</span> <span class="o">=</span> <span class="n">value</span></div>


<span class="n">GmshMesh</span> <span class="o">=</span> <span class="n">GmshMeshGenerator</span>


<div class="viewcode-block" id="trimesh2d"><a class="viewcode-back" href="../../calfem_reference.html#calfem.mesh.trimesh2d">[docs]</a><span class="k">def</span> <span class="nf">trimesh2d</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">segments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxArea</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quality</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dofs_per_node</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">logFilename</span><span class="o">=</span><span class="s2">&quot;tri.log&quot;</span><span class="p">,</span> <span class="n">triangleExecutablePath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Triangulates an area described by a number vertices (vertices) and a set</span>
<span class="sd">    of segments that describes a closed polygon. </span>

<span class="sd">    Parameters:</span>

<span class="sd">        vertices            array [nVertices x 2] with vertices describing the geometry.</span>

<span class="sd">                            [[v0_x, v0_y],</span>
<span class="sd">                             [   ...    ],</span>
<span class="sd">                             [vn_x, vn_y]]</span>

<span class="sd">        segments            array [nSegments x 3] with segments describing the geometry.</span>

<span class="sd">                            [[s0_v0, s0_v1,marker],</span>
<span class="sd">                             [        ...        ],</span>
<span class="sd">                             [sn_v0, sn_v1,marker]]</span>

<span class="sd">        holes               [Not currently used]</span>

<span class="sd">        maxArea             Maximum area for triangle. (None)</span>

<span class="sd">        quality             If true, triangles are prevented having angles &lt; 30 degrees. (True)</span>

<span class="sd">        dofs_per_node         Number of degrees of freedom per node.</span>

<span class="sd">        logFilename         Filename for triangle output (&quot;tri.log&quot;)</span>

<span class="sd">    Returns:</span>

<span class="sd">        coords              Node coordinates</span>

<span class="sd">                            [[n0_x, n0_y],</span>
<span class="sd">                             [   ...    ],</span>
<span class="sd">                             [nn_x, nn_y]]</span>

<span class="sd">        edof                Element topology</span>

<span class="sd">                            [[el0_dof1, ..., el0_dofn],</span>
<span class="sd">                             [          ...          ],</span>
<span class="sd">                             [eln_dof1, ..., eln_dofn]]</span>

<span class="sd">        dofs                Node dofs</span>

<span class="sd">                            [[n0_dof1, ..., n0_dofn],</span>
<span class="sd">                             [         ...         ],</span>
<span class="sd">                             [nn_dof1, ..., nn_dofn]]</span>

<span class="sd">        bdofs               Boundary dofs. Dictionary containing lists of dofs for</span>
<span class="sd">                            each boundary marker. Dictionary key = marker id.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check for triangle executable</span>

    <span class="n">triangleExecutable</span> <span class="o">=</span> <span class="n">triangleExecutablePath</span>

    <span class="k">if</span> <span class="n">triangleExecutable</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">triangleExecutable</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
            <span class="n">triangleExecutable</span> <span class="o">=</span> <span class="n">which</span><span class="p">(</span><span class="s2">&quot;triangle.exe&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">triangleExecutable</span> <span class="o">=</span> <span class="n">which</span><span class="p">(</span><span class="s2">&quot;triangle&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">triangleExecutable</span><span class="p">):</span>
            <span class="n">triangleExecutable</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">triangleExecutable</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error: Could not find triangle. Please make sure that the </span><span class="se">\n</span><span class="s2">triangle executable is available on the search path (PATH).&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1"># Create triangle options</span>

    <span class="n">options</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="k">if</span> <span class="n">maxArea</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="s2">&quot;-a</span><span class="si">%f</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="n">maxArea</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
    <span class="k">if</span> <span class="n">quality</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">+=</span> <span class="s2">&quot;-q&quot;</span>

    <span class="c1"># Set initial variables</span>

    <span class="n">nSegments</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nHoles</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nAttribs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nBoundaryMarkers</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">nVertices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

    <span class="c1"># All files are created as temporary files</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s2">&quot;./trimesh.temp&quot;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s2">&quot;./trimesh.temp&quot;</span><span class="p">)</span>

    <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;./trimesh.temp/polyfile.poly&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">segments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nSegments</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">holes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nHoles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">holes</span><span class="p">)</span>

    <span class="c1"># Create a .poly file</span>

    <span class="n">polyFile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
    <span class="n">polyFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> 2 </span><span class="si">%d</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nVertices</span><span class="p">,</span> <span class="n">nAttribs</span><span class="p">))</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="n">polyFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">polyFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nSegments</span><span class="p">,</span> <span class="n">nBoundaryMarkers</span><span class="p">))</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
        <span class="n">polyFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span>
                       <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">segment</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">polyFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;0</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">polyFile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># Execute triangle</span>

    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> &gt; tri.log&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">triangleExecutable</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span>

    <span class="c1"># Read results from triangle</span>

    <span class="n">strippedName</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">nodeFilename</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.1.node&quot;</span> <span class="o">%</span> <span class="n">strippedName</span>
    <span class="n">elementFilename</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.1.ele&quot;</span> <span class="o">%</span> <span class="n">strippedName</span>
    <span class="n">polyFilename</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.1.poly&quot;</span> <span class="o">%</span> <span class="n">strippedName</span>

    <span class="c1"># Read vertices</span>

    <span class="n">allVertices</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">boundaryVertices</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">nodeFilename</span><span class="p">):</span>
        <span class="n">nodeFile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">nodeFilename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">nodeInfo</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">nodeFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>

        <span class="n">nNodes</span> <span class="o">=</span> <span class="n">nodeInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">allVertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nNodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nNodes</span><span class="p">):</span>
            <span class="n">vertexRow</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">nodeFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>

            <span class="n">boundaryMarker</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">vertexRow</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">boundaryMarker</span> <span class="ow">in</span> <span class="n">boundaryVertices</span><span class="p">):</span>
                <span class="n">boundaryVertices</span><span class="p">[</span><span class="n">boundaryMarker</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">allVertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertexRow</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vertexRow</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">boundaryVertices</span><span class="p">[</span><span class="n">boundaryMarker</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">nodeFile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># Read elements</span>

    <span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">elementFilename</span><span class="p">):</span>
        <span class="n">elementFile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">elementFilename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">elementInfo</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">elementFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>

        <span class="n">nElements</span> <span class="o">=</span> <span class="n">elementInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nElements</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nElements</span><span class="p">):</span>
            <span class="n">elementRow</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">elementFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
            <span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">elementRow</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                              <span class="n">elementRow</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">elementRow</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">elementFile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># Clean up</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">pass</span>
        <span class="c1"># os.remove(filename)</span>
        <span class="c1"># os.remove(nodeFilename)</span>
        <span class="c1"># os.remove(elementFilename)</span>
        <span class="c1"># os.remove(polyFilename)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Add dofs in edof and bcVerts</span>

    <span class="n">dofs</span> <span class="o">=</span> <span class="n">cfc</span><span class="o">.</span><span class="n">createdofs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">allVertices</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dofs_per_node</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dofs_per_node</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">expandedElements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="o">*</span><span class="n">dofs_per_node</span><span class="p">),</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span>
        <span class="n">dofs</span> <span class="o">=</span> <span class="n">cfc</span><span class="o">.</span><span class="n">createdofs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">allVertices</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dofs_per_node</span><span class="p">)</span>

        <span class="n">elIdx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">elementTopo</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">expandedElements</span><span class="p">[</span><span class="n">elIdx</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">dofs_per_node</span><span class="p">:(</span>
                    <span class="n">i</span><span class="o">*</span><span class="n">dofs_per_node</span><span class="o">+</span><span class="n">dofs_per_node</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dofs</span><span class="p">[</span><span class="n">elementTopo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">elIdx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">bVertIdx</span> <span class="ow">in</span> <span class="n">boundaryVertices</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">bVert</span> <span class="o">=</span> <span class="n">boundaryVertices</span><span class="p">[</span><span class="n">bVertIdx</span><span class="p">]</span>
            <span class="n">bVertNew</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bVert</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dofs_per_node</span><span class="p">):</span>
                    <span class="n">bVertNew</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dofs</span><span class="p">[</span><span class="n">bVert</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>

            <span class="n">boundaryVertices</span><span class="p">[</span><span class="n">bVertIdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">bVertNew</span>

        <span class="k">return</span> <span class="n">allVertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">expandedElements</span><span class="p">),</span> <span class="n">dofs</span><span class="p">,</span> <span class="n">boundaryVertices</span>

    <span class="k">return</span> <span class="n">allVertices</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">dofs</span><span class="p">,</span> <span class="n">boundaryVertices</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2016-2020, Jonas Lindemann.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>