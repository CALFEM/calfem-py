Examples
========

Connected springs (exs1.m)
--------------------------

This example is from the CALFEM manual.

**Purpose:**

Show the basic steps in a finite element calculation.

**Description:**

The general procedure in linear finite element calculations is carried out for a simple
structure. The steps are:

 * define the model
 * generate element matrices
 * assemble element matrices into the global system of equations
 * solve the global system of equations
 * evalueate element forces

Consider the system of three linear elastic springs, and the corresponding finite
element model. The system of springs is fixed in its ends and loaded by a single
load F.

.. image:: images/exs1-1.png

Import required modules::

    In [1]: import numpy as np
    In [2]: import calfem.core as cfc

The computation is initialized by defining the topology matrix Edof, containing
element numbers and global element degrees of freedom,::

    In [3]: Edof = np.array([
    ...: [1,2],
    ...: [2,3],
    ...: [2,3]
    ...: ])

the global stiffness matrix K (3x3) of zeros,::

    In [4]: K = np.matrix(np.zeros((3,3)))
    In [5]: print(K)
    [[ 0.  0.  0.]
     [ 0.  0.  0.]
     [ 0.  0.  0.]]

and the load vector f (3x1) with the load F = 100 in position 2.::

    In [7]: f = np.matrix(np.zeros((3,1))); f[1] = 100
    In [8]: print(f)
    [[   0.]
     [ 100.]
     [   0.]]

Element stiffness matrices are generated by the function spring1e. The element
property ep for the springs contains the spring stiffnesses k and 2k respectively,
where k = 1500.::

    In [9]: k = 1500.; ep1 = k; ep2 = 2.*k
    In [11]: Ke1 = cfc.spring1e(ep1)
    In [12]: print(Ke1)
    [[ 1500. -1500.]
     [-1500.  1500.]]

    In [13]: Ke2 = cfc.spring1e(ep2)
    In [14]: print(Ke2)
    [[ 3000. -3000.]
     [-3000.  3000.]]

The element stiffness matrices are assembled into the global stiffness matrix K
according to the topology.::

    In []: cfc.assem(Edof[0,:], K, Ke2)
    Out[16]: 
    matrix([[ 3000., -3000.,     0.],
            [-3000.,  3000.,     0.],
            [    0.,     0.,     0.]])

    In []: cfc.assem(Edof[1,:], K, Ke1)
    Out[17]: 
    matrix([[ 3000., -3000.,     0.],
            [-3000.,  4500., -1500.],
            [    0., -1500.,  1500.]])

    In []: cfc.assem(Edof[2,:], K, Ke2)
    Out[18]: 
    matrix([[ 3000., -3000.,     0.],
            [-3000.,  7500., -4500.],
            [    0., -4500.,  4500.]])

The global system of equations is solved considering the boundary conditions given
in bc.::

    In [19]: bc = np.array([1,3])
    In [20]: a, r = cfc.solveq(K, f, bc)
    In [21]: print(a)
    [[ 0.        ]
     [ 0.01333333]
     [ 0.        ]]

    In [22]: print(r)
    [[-40.]
     [  0.]
     [-60.]]

Element forces are evaluated from the element displacements. These are obtained
from the global displacements a using the function extract.::

    In [23]: ed1 = cfc.extractEldisp(Edof[0,:], a)
    In [24]: print(ed1)
    [ 0.          0.01333333]

    In [25]: ed2 = cfc.extractEldisp(Edof[1,:], a)
    In [26]: print(ed2)
    [ 0.01333333  0.        ]

    In [27]: ed3 = cfc.extractEldisp(Edof[2,:], a)
    In [28]: print(ed3)
    [ 0.01333333  0.    

The spring forces are evaluated using the function spring1s.::

    In [29]: es1 = cfc.spring1s(ep2,ed1)
    In [30]: print(es1)
    40.0

    In [31]: es2 = cfc.spring1s(ep1,ed2)
    In [32]: print(es2)
    -20.0

    In [33]: es3 = cfc.spring1s(ep2,ed3)
    In [34]: print(es3)
    -40.0
